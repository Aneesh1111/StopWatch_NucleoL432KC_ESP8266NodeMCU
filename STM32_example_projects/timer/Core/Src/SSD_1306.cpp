/*
 * SSD_1306.cpp
 *
 *  Created on: Jan 29, 2021
 *      Author: harbanse
 */

#include <bitset>
#include <SSD_1306.hpp>

#define SSD1306_SETCONTRAST 0x81
#define SSD1306_DISPLAYALLON_RESUME 0xA4
#define SSD1306_DISPLAYALLON 0xA5
#define SSD1306_NORMALDISPLAY 0xA6
#define SSD1306_INVERTDISPLAY 0xA7
#define SSD1306_DISPLAYOFF 0xAE
#define SSD1306_DISPLAYON 0xAF
#define SSD1306_SETDISPLAYOFFSET 0xD3
#define SSD1306_SETCOMPINS 0xDA
#define SSD1306_SETVCOMDETECT 0xDB
#define SSD1306_SETDISPLAYCLOCKDIV 0xD5
#define SSD1306_SETPRECHARGE 0xD9
#define SSD1306_SETMULTIPLEX 0xA8
#define SSD1306_SETLOWCOLUMN 0x00
#define SSD1306_SETHIGHCOLUMN 0x10
#define SSD1306_SETSTARTLINE 0x40
#define SSD1306_MEMORYMODE 0x20
#define SSD1306_COMSCANINC 0xC0
#define SSD1306_COMSCANDEC 0xC8
#define SSD1306_SEGREMAP 0xA0
#define SSD1306_CHARGEPUMP 0x8D

void SSD_1306::begin(uint8_t vccstate)
{
	HAL_GPIO_WritePin(RST_GPIO_Port, RST_Pin, GPIO_PIN_SET); 	//rst = 1;
    // VDD (3.3V) goes high at start, lets just chill for a ms
    osDelay(1);
    // bring reset low
    HAL_GPIO_WritePin(RST_GPIO_Port, RST_Pin, GPIO_PIN_RESET);	//rst = 0;
    // wait 10ms
    osDelay(10);
    // bring out of reset
    HAL_GPIO_WritePin(RST_GPIO_Port, RST_Pin, GPIO_PIN_SET);	//rst = 1;
    // turn on VCC (9V?)

    command(SSD1306_DISPLAYOFF);
    command(SSD1306_SETDISPLAYCLOCKDIV);
    command(0x80);                                  // the suggested ratio 0x80

    command(SSD1306_SETMULTIPLEX);
    command(height-1);

    command(SSD1306_SETDISPLAYOFFSET);
    command(0x00);                                   // no offset

    command(SSD1306_SETSTARTLINE | 0x40);            // line #0

    command(SSD1306_CHARGEPUMP);
    command((vccstate == SSD1306_EXTERNALVCC) ? 0x10 : 0x14);

    command(SSD1306_MEMORYMODE);
    command(0x00);                                  // 0x0 act like ks0108

    command(SSD1306_SEGREMAP | 0x1);

    command(SSD1306_COMSCANDEC);

    command(SSD1306_SETCOMPINS);
    command(height == 32 ? 0x02 : 0x12);

    command(SSD1306_SETCONTRAST);
    command(height == 0x32 ? 0x8F : ((vccstate == SSD1306_EXTERNALVCC) ? 0x9F : 0xCF) );

    command(SSD1306_SETPRECHARGE);
    command((vccstate == SSD1306_EXTERNALVCC) ? 0x22 : 0xF1);

    command(SSD1306_SETVCOMDETECT);
    command(0x40);

    command(SSD1306_DISPLAYALLON_RESUME);

    command(SSD1306_NORMALDISPLAY);

    command(SSD1306_DISPLAYON);

}


void SSD_1306::command(uint8_t c)
{

	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
	HAL_GPIO_WritePin(DC_GPIO_Port, DC_Pin, GPIO_PIN_RESET);	//dc = 0;
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);	//cs = 0;
	//mspi.write(c);
	HAL_SPI_Transmit(&hspi1, &c, 1, 0);
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
}

void SSD_1306::data(uint8_t c)
{
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
	HAL_GPIO_WritePin(DC_GPIO_Port, DC_Pin, GPIO_PIN_SET);	//dc = 1;
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);	//cs = 0;
	//mspi.write(c);
	HAL_SPI_Transmit(&hspi1, &c, 1, 0);
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
}

/// Clear the display buffer
void SSD_1306::clearDisplay(void)
{
	std::fill(buffer.begin(), buffer.end(), 0);
}

void SSD_1306::invertDisplay(bool i)
{
	command(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
}

// Send the display buffer out to the display
void SSD_1306::display(void)
{
	command(SSD1306_SETLOWCOLUMN | 0x00);  // low col = 0
	command(SSD1306_SETHIGHCOLUMN | 0x00);  // hi col = 0
	command(SSD1306_SETSTARTLINE | 0x00); // line #0
	sendDisplayBuffer();
}

void SSD_1306::sendDisplayBuffer()
{
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
	HAL_GPIO_WritePin(DC_GPIO_Port, DC_Pin, GPIO_PIN_SET);	//dc = 1;
	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_RESET);	//cs = 0;

	uint16_t q = buffer.size();
	uint8_t item;
#ifdef LOW_SPEED
//	uint8_t *buff_ptr = &buffer.front();
//	HAL_SPI_Transmit(&hspi1, buff_ptr, q, 0);

	for (uint16_t i=0; i <q; i++)
	{
		item = buffer[i];
		HAL_SPI_Transmit(&hspi1, &item, 1, 0);
	}
#else
	uint8_t *buff_ptr = &buffer.front();
	HAL_SPI_Transmit(&hspi1, buff_ptr, q, 10);
#endif

	//TODO: why? need to write to all the RAM - 1024 in total

	if (height == 32)
	{
		uint16_t q = buffer.size();
		item = 0;
#ifdef LOW_SPEED
		for (uint16_t i=0; i<q; i++)
		{
			HAL_SPI_Transmit(&hspi1, &item, 1, 0);

		}
#else
		uint8_t *buff_ptr = &buffer.front();
		HAL_StatusTypeDef hal = HAL_SPI_Transmit(&hspi1, buff_ptr, q, 10);
#endif
	}

	HAL_GPIO_WritePin(CS_GPIO_Port, CS_Pin, GPIO_PIN_SET); //cs = 1;
}

void SSD_1306::splash(void)
{
#ifdef USING_LOGO
	const uint8_t adaFruitLogo[512] =
	{
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
		0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
		0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
		0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
		0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
		0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
		0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
		0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
		0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
		0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
		0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
		0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
		0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
		0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
		0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
		0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
		0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
		0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
		0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		// 128x32^^^  128x64vvv
		0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
		0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
		0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
		0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
		0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
		0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
		0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
		0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
		0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
		0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
		0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
		0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
		0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
		0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00

	};

	std::copy(
		&adaFruitLogo[0]
		, &adaFruitLogo[0] + (height == 32 ? sizeof(adaFruitLogo)/2 : sizeof(adaFruitLogo))
		, buffer.begin()
		);
#endif
}

void SSD_1306::write_char(uint8_t text_position, uint8_t c)
{
	uint16_t pixel_position = 0;
	if (text_position < 21)
	{
		pixel_position = text_position*6;
	}
	else if (text_position < 42)
	{
		pixel_position = 128 + (text_position-21)*6;
	}
	else if (text_position < 63)
	{
		pixel_position = 256 + (text_position-42)*6;
	}
	else
	{
		pixel_position = 384 + (text_position-63)*6;
	}

	for (uint8_t i=0;i < 5; i++)
	{
		uint8_t f = font[c*5 + i];
		buffer[i+pixel_position] = f;
	}
}

void SSD_1306::write_char_16(uint16_t text_position, uint8_t c)
{
	const uint16_t spacing = 12;
	uint16_t pixel_position = 0;
	if (text_position < 10)
	{
		pixel_position = text_position * spacing;
	}
	else
	{
		pixel_position = 256 + (text_position - 10)*spacing;
	}

	for (uint8_t j=0; j<5; j++)
	{
		std::bitset<8> old_char = font[c*5+j];
		std::bitset<16> new_char = 0;
		for (uint8_t i = 0; i<8; i++)
		{
			if (old_char.test(i))
			{
				new_char.set(i*2);
				new_char.set(i*2 + 1);
			}
		}

		uint16_t u = new_char.to_ulong();
		uint8_t lsb = (uint8_t) (u & 0x00FF);;
		uint8_t msb = (uint8_t) (u >> 8);

		buffer[pixel_position + 2*j] = lsb;
		buffer[pixel_position + 1 + 2*j] = lsb;
		buffer[pixel_position + 128 + 2*j] = msb;
		buffer[pixel_position + 129 + 2*j] = msb;
	}
}

void SSD_1306::write_char_32(uint16_t text_position, uint8_t c)
{
	const uint16_t spacing = 24;
	uint16_t pixel_position = 0;

	//there is only one line with this text size
	pixel_position = text_position * spacing;

	for (uint8_t j=0; j<5; j++)
	{
		std::bitset<8> old_char = font[c*5+j];
		std::bitset<32> new_char = 0;
		for (uint8_t i = 0; i<8; i++)
		{
			if (old_char.test(i))
			{
				new_char.set(i*4);
				new_char.set(i*4 + 1);
				new_char.set(i*4 + 2);
				new_char.set(i*4 + 3);
			}
		}

		uint32_t u = new_char.to_ulong();
		uint8_t bytes[4];
		bytes[0] = (uint8_t) (u & 0xFF);
		bytes[1] = (uint8_t) ((u >> 8) & 0xFF);
		bytes[2] = (uint8_t) ((u >> 16) & 0xFF);
		bytes[3] = (uint8_t) ((u >> 24) & 0xFF);

		//16 copies here!
//		buffer[pixel_position + 4*j] = byte[0];
//		buffer[pixel_position + 1 + 4*j] = byte[0];
//		buffer[pixel_position + 2 + 4*j] = byte[0];
//		buffer[pixel_position + 3 + 4*j] = byte[0];
//
//		buffer[pixel_position + 128 + 4*j] = byte[1];
//		buffer[pixel_position + 129 + 4*j] = byte[1];
//		buffer[pixel_position + 130 + 4*j] = byte[1];
//		buffer[pixel_position + 121 + 4*j] = byte[1];
//
//		buffer[pixel_position + 256 + 4*j] = byte[2];
//
//		buffer[pixel_position + 384 + 4*j] = byte[3];

		for (uint8_t copies=0; copies < 4; copies++)
		{
			buffer[pixel_position + copies + 4*j] = bytes[0];
			buffer[pixel_position + copies + 128 + 4*j] = bytes[1];
			buffer[pixel_position + copies + 256 + 4*j] = bytes[2];
			buffer[pixel_position + copies + 384 + 4*j] = bytes[3];
		}

	}
}

void SSD_1306::write_str(uint8_t text_position, char* str)
{
	uint8_t position = text_position;
	uint8_t i = 0 ;
	while (str[i])
	{
		if (text_size == 4)
		{
			write_char_32(position, str[i]);
		}
		else if (text_size == 2)
		{
			write_char_16(position, str[i]);
		}
		else
		{
			write_char(position, str[i]);
		}
		i++;
		position++;
	}
}

void SSD_1306::write_str_16(uint8_t text_position, char* str)
{
	uint8_t position = text_position;
	uint8_t i = 0 ;
	while (str[i])
	{
		write_char_16(position, str[i]);
		i++;
		position++;
	}
}

//void SSD_1306::write_str_16(uint8_t text_position, char* str)
//{
//	uint8_t position = text_position;
//	uint8_t i = 0 ;
//	while (str[i])
//	{
//		write_char_16(position, str[i]);
//		i++;
//		position++;
//	}
//}
